"""
seed_data.py – Populate the SafeRoutes database with Edinburgh street data.

Run once (or whenever the database is empty) to create:
  - 20 fictional university student users
  - Edinburgh street records loaded from data/streets_list.py
    (generated by extract_streets.py) or from a built-in fallback list
  - Dynamically generated safety ratings for all streets and times of day

Run extract_streets.py first to get full Edinburgh coverage (~1500+ streets).
Without it the app still works using the built-in 50-street fallback list.
"""
import random
import importlib.util
from datetime import datetime, timedelta
from pathlib import Path

# ── Try loading the auto-generated streets list ───────────────────────────────
_STREETS_FILE = Path(__file__).parent / "data" / "streets_list.py"


def _load_generated_streets():
    """Import STREETS from data/streets_list.py if it exists."""
    if not _STREETS_FILE.exists():
        return None
    spec = importlib.util.spec_from_file_location("streets_list", str(_STREETS_FILE))
    mod  = importlib.util.module_from_spec(spec)
    try:
        spec.loader.exec_module(mod)
        return getattr(mod, "STREETS", None)
    except Exception as e:
        print(f"[seed] Could not load streets_list.py: {e}")
        return None


# ── Built-in fallback: 50 key Edinburgh streets ───────────────────────────────
# Used when extract_streets.py hasn't been run yet.
# Format: (name, latitude, longitude, crime_rate_normalised, lighting_score)
STREETS_FALLBACK = [
    # Central / Old Town – busy tourist zone, moderate–high crime
    ("Princes Street",       55.9523, -3.1920, 0.45, 0.90),
    ("Royal Mile",           55.9493, -3.1893, 0.55, 0.75),
    ("The Mound",            55.9502, -3.1942, 0.40, 0.70),
    ("Cockburn Street",      55.9488, -3.1891, 0.50, 0.65),
    ("South Bridge",         55.9475, -3.1862, 0.45, 0.80),
    ("North Bridge",         55.9513, -3.1872, 0.40, 0.85),
    ("Chambers Street",      55.9469, -3.1892, 0.35, 0.80),
    ("Blair Street",         55.9477, -3.1879, 0.60, 0.60),
    ("Jeffrey Street",       55.9492, -3.1862, 0.50, 0.65),
    # Nightlife corridors – high crime especially at night
    ("Cowgate",              55.9473, -3.1895, 0.75, 0.50),
    ("Grassmarket",          55.9468, -3.1951, 0.70, 0.60),
    ("Lothian Road",         55.9455, -3.2048, 0.65, 0.82),
    ("West Port",            55.9466, -3.2016, 0.65, 0.65),
    ("The Pleasance",        55.9462, -3.1843, 0.40, 0.68),
    # New Town – safe, well-lit commercial and residential
    ("George Street",        55.9535, -3.2005, 0.25, 0.90),
    ("Queen Street",         55.9546, -3.2008, 0.22, 0.88),
    ("Hanover Street",       55.9528, -3.1953, 0.28, 0.85),
    ("Frederick Street",     55.9527, -3.2020, 0.25, 0.85),
    ("Rose Street",          55.9530, -3.2010, 0.30, 0.82),
    ("Castle Street",        55.9525, -3.2007, 0.28, 0.85),
    ("Young Street",         55.9533, -3.2030, 0.24, 0.80),
    # Newington / student area – moderate, well-patrolled
    ("Nicolson Street",      55.9449, -3.1862, 0.35, 0.78),
    ("Clerk Street",         55.9398, -3.1841, 0.28, 0.75),
    ("Dalkeith Road",        55.9363, -3.1745, 0.20, 0.72),
    ("Mayfield Road",        55.9317, -3.1740, 0.18, 0.70),
    ("South Clerk Street",   55.9430, -3.1843, 0.30, 0.76),
    ("Causewayside",         55.9375, -3.1847, 0.25, 0.72),
    # Marchmont / Bruntsfield – quiet residential, very safe
    ("Marchmont Road",       55.9355, -3.1879, 0.15, 0.68),
    ("Bruntsfield Place",    55.9372, -3.2022, 0.18, 0.72),
    ("Morningside Road",     55.9285, -3.2055, 0.10, 0.75),
    ("Gilmore Place",        55.9402, -3.2071, 0.20, 0.70),
    ("Warrender Park Road",  55.9345, -3.1925, 0.14, 0.67),
    ("Spottiswoode Street",  55.9340, -3.1970, 0.13, 0.65),
    # Leith – improving but still mixed at night
    ("Leith Walk",           55.9640, -3.1759, 0.55, 0.72),
    ("Easter Road",          55.9634, -3.1625, 0.45, 0.68),
    ("Junction Street",      55.9734, -3.1723, 0.55, 0.65),
    ("Ferry Road",           55.9656, -3.2148, 0.30, 0.75),
    ("Constitution Street",  55.9723, -3.1733, 0.50, 0.68),
    # Stockbridge / Dean – village-like, very safe, some dark paths
    ("Raeburn Place",        55.9587, -3.2128, 0.12, 0.80),
    ("Dean Path",            55.9537, -3.2196, 0.10, 0.45),
    ("Queensferry Street",   55.9520, -3.2148, 0.25, 0.82),
    ("Henderson Row",        55.9576, -3.2094, 0.13, 0.78),
    ("St Stephen Street",    55.9573, -3.2080, 0.15, 0.72),
    # West / Haymarket / Gorgie – mixed, improving
    ("Haymarket Terrace",    55.9452, -3.2180, 0.35, 0.80),
    ("Dalry Road",           55.9424, -3.2227, 0.42, 0.72),
    ("Gorgie Road",          55.9352, -3.2380, 0.45, 0.65),
    ("Fountainbridge",       55.9426, -3.2105, 0.40, 0.72),
    ("Morrison Street",      55.9442, -3.2175, 0.38, 0.75),
    # Scenic / isolated paths – low crime but poor lighting
    ("Calton Road",          55.9516, -3.1812, 0.42, 0.45),
    ("Regent Road",          55.9547, -3.1800, 0.30, 0.55),
    ("Holyrood Road",        55.9495, -3.1800, 0.38, 0.65),
    ("Waterloo Place",       55.9525, -3.1845, 0.32, 0.80),
]

# ── Fictional student users ───────────────────────────────────────────────────
USERS = [
    ("aisling_m",  "aisling.m@ed.ac.uk",       "University of Edinburgh"),
    ("zoe_r",      "zoe.r@ed.ac.uk",            "University of Edinburgh"),
    ("priya_k",    "priya.k@hw.ac.uk",          "Heriot-Watt University"),
    ("lucy_j",     "lucy.j@ed.ac.uk",           "University of Edinburgh"),
    ("mei_chen",   "mei.chen@ed.ac.uk",         "University of Edinburgh"),
    ("niamh_o",    "niamh.o@napier.ac.uk",      "Edinburgh Napier University"),
    ("sarah_b",    "sarah.b@ed.ac.uk",          "University of Edinburgh"),
    ("fatima_a",   "fatima.a@ed.ac.uk",         "University of Edinburgh"),
    ("claire_d",   "claire.d@caledonian.ac.uk", "Edinburgh Caledonian University"),
    ("rosa_v",     "rosa.v@ed.ac.uk",           "University of Edinburgh"),
    ("elena_p",    "elena.p@hw.ac.uk",          "Heriot-Watt University"),
    ("sophie_t",   "sophie.t@ed.ac.uk",         "University of Edinburgh"),
    ("anna_w",     "anna.w@napier.ac.uk",       "Edinburgh Napier University"),
    ("jade_h",     "jade.h@ed.ac.uk",           "University of Edinburgh"),
    ("nadia_c",    "nadia.c@ed.ac.uk",          "University of Edinburgh"),
    ("emma_f",     "emma.f@hw.ac.uk",           "Heriot-Watt University"),
    ("tara_n",     "tara.n@ed.ac.uk",           "University of Edinburgh"),
    ("isla_m",     "isla.m@ed.ac.uk",           "University of Edinburgh"),
    ("chloe_s",    "chloe.s@napier.ac.uk",      "Edinburgh Napier University"),
    ("yuki_t",     "yuki.t@ed.ac.uk",           "University of Edinburgh"),
]


def _rating_profile(crime_rate: float, lighting_score: float,
                    time_of_day: str) -> tuple:
    """
    Derive (mean_score, std_dev) for ratings on a street at a given time.

    Logic:
      • Base safety is primarily the inverse of crime rate
      • Lighting adds a small bonus during the day, a larger one at night
      • All streets feel less safe at night – even Morningside has lower scores
      • Standard deviation is higher for borderline streets (more disagreement)

    Returns mean_score on the 1–5 scale and std_dev for Gaussian sampling.
    """
    base = max(0.05, min(0.95, 1.0 - crime_rate + 0.15 * (lighting_score - 0.5)))

    if time_of_day == "day":
        safety = base
    elif time_of_day == "evening":
        safety = base * 0.88 + lighting_score * 0.04
    else:  # night
        # At night, lighting becomes the dominant factor
        safety = base * 0.72 + lighting_score * 0.10

    safety = max(0.05, min(0.90, safety))

    mean_score = max(1.1, min(4.9, 1.0 + safety * 4.0))

    # Borderline streets (safety ≈ 0.5) have higher variance
    centrality = abs(safety - 0.5)    # 0 = borderline, 0.5 = clearly safe/unsafe
    std_dev    = max(0.25, 0.75 - 0.40 * centrality)

    return mean_score, std_dev


def seed(app, db_instance):
    """
    Seed the database with Edinburgh street data and synthetic safety ratings.
    Safe to call multiple times – skips seeding if data already present.
    """
    from models.database import User, SafetyRating, Street

    with app.app_context():
        if User.query.count() > 0:
            print("[seed] Database already contains data – skipping seed.")
            return

        random.seed(42)

        # ── Load streets ──────────────────────────────────────────────────────
        streets_data = _load_generated_streets()
        if streets_data:
            print(f"[seed] Loaded {len(streets_data):,} streets from data/streets_list.py")
        else:
            streets_data = STREETS_FALLBACK
            print(f"[seed] Using built-in fallback list ({len(streets_data)} streets)")
            print("[seed]   Tip: run extract_streets.py first for full coverage")

        # ── Users ─────────────────────────────────────────────────────────────
        print("[seed] Seeding users...")
        user_objects = []
        for (uname, email, uni) in USERS:
            u = User(username=uname, email=email, university=uni)
            u.set_password("password123")
            db_instance.session.add(u)
            user_objects.append(u)
        db_instance.session.flush()

        # ── Streets ───────────────────────────────────────────────────────────
        print("[seed] Seeding streets...")
        street_objects = {}
        for (name, lat, lng, crime, lighting) in streets_data:
            s = Street(
                name=name,
                latitude=lat,
                longitude=lng,
                crime_rate_normalised=crime,
                lighting_score=lighting,
                avg_user_score=0.5,
                composite_safety_score=0.5,
            )
            db_instance.session.add(s)
            street_objects[name] = s
        db_instance.session.flush()

        # ── Safety ratings ────────────────────────────────────────────────────
        # Generate 3–5 ratings per (street, time_of_day) combination.
        # Profiles are derived from each street's crime_rate and lighting_score
        # so the ML models have a realistic and varied training set.
        print("[seed] Seeding safety ratings...")
        n_ratings  = 0
        base_time  = datetime.utcnow() - timedelta(days=180)

        for (name, lat, lng, crime, lighting) in streets_data:
            street = street_objects[name]
            for tod in ("day", "evening", "night"):
                mean_score, std_dev = _rating_profile(crime, lighting, tod)
                n = random.randint(3, 5)
                for _ in range(n):
                    raw   = random.gauss(mean_score, std_dev)
                    score = max(1, min(5, round(raw)))
                    user  = random.choice(user_objects)

                    # Small coordinate jitter around the street midpoint
                    jlat = lat + random.uniform(-0.0015, 0.0015)
                    jlng = lng + random.uniform(-0.0015, 0.0015)

                    created = base_time + timedelta(
                        days=random.randint(0, 180),
                        hours=random.randint(0, 23),
                        minutes=random.randint(0, 59),
                    )

                    rating = SafetyRating(
                        user_id=user.id,
                        latitude=jlat,
                        longitude=jlng,
                        street_name=name,
                        safety_score=score,
                        time_of_day=tod,
                        comment=None,
                        created_at=created,
                    )
                    db_instance.session.add(rating)
                    n_ratings += 1

        # ── Initial avg_user_score per street ─────────────────────────────────
        db_instance.session.flush()
        for street in street_objects.values():
            ratings = SafetyRating.query.filter_by(street_name=street.name).all()
            if ratings:
                avg = sum(r.safety_score for r in ratings) / len(ratings)
                street.avg_user_score = (avg - 1) / 4.0   # normalise 1–5 → 0–1

        db_instance.session.commit()
        print(
            f"[seed] Done.  {len(USERS)} users | "
            f"{len(streets_data):,} streets | "
            f"{n_ratings:,} ratings"
        )
